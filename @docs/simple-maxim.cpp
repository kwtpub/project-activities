#include <iostream>
#include <cmath>
#include <iomanip>

using namespace std;

// Функция, которую интегрируем для 1 и 3 задания

double f(double x) 
{
// Вычисляем значение функции sin(x² + 2.5) / (x³ + 3)
return sin(x * x + 2.5) / (x * x * x + 3);
}

// Метод трапеций для вычисления интеграла (использует прямые линии, тем самым разбивает фигуру на трапеции)
double trapezoid(double start, double end, int parts) // parts - на сколько частей разбиваем интервал
{
// Вычисляем ширину одного отрезка
double step = (end - start) / parts; // Это шаг, с которым мы движемся от одной точки к другой.
// Начальная сумма - полусумма значений на краях
double total = (f(start) + f(end)) / 2;

// Суммируем значения функции во всех внутренних точках
for (int i = 1; i < parts; i++) 
{
total += f(start + i * step); //вычисление координат в текущей точке. Пр:i = 1: 0.4 + 1 × 0.3 = 0.7
} // i * step - смещение от начала

// Умножаем накопленную сумму на ширину шага и получаем приближённое значение интеграла.
return total * step;
}

// Метод Симпсона для вычисления интеграла (использует параболы для приближения кривой. Это как если бы мы соединяли точки не отрезками, а плавными изгибами)
double simpson(double start, double end, int parts) 
{
// Метод Симпсона требует четного числа отрезков (работаем с тройками точек)
if (parts % 2 != 0) 
{
parts++; // Если передали нечётное - делаем чётным
} 
// Вычисляем ширину одного отрезка
double step = (end - start) / parts;
// Начальная сумма - значения на краях
double total = f(start) + f(end);

// Суммируем значения с разными коэффициентами
for (int i = 1; i < parts; i++) 
{
// Для четных точек коэффициент - 2, для нечетных - 4
if (i % 2 == 0) 
{
total += 2 * f(start + i * step);
} else 
{
total += 4 * f(start + i * step);
}
}

// Умножаем на шаг и делим на 3 по формуле Симпсона
return total * step / 3;
}

// Метод прямоугольников (левых)
double rectangles(double start, double end, int parts) 
{
// Вычисляем ширину одного прямоугольника
double step = (end - start) / parts;
// Сумма площадей прямоугольников
double total = 0;

// Суммируем площади всех прямоугольников
for (int i = 0; i < parts; i++) 
{
// Вычисляем x-координату левой стороны прямоугольника
double x = start + i * step;
// Добавляем высоту прямоугольника (значение функции)
total += f(x);
}

// Умножаем сумму высот на ширину для получения общей площади
return total * step;
}





// Функция, которую интегрируем для 2 задания

double f2(double x) 
{
// Вычисляем значение функции 1/√(x³ + 1)
return 1.0 / sqrt(x * x * x + 1);
}

// Метод прямоугольников (левых)
double T_rectangles(double start, double end, int parts) 
{
// Вычисляем ширину одного прямоугольника
double step = (end - start) / parts;
// Сумма площадей прямоугольников
double total = 0;

// Суммируем площади всех прямоугольников
for (int i = 0; i < parts; i++) {
// Вычисляем x-координату левой стороны прямоугольника
double x = start + i * step;
// Добавляем высоту прямоугольника (значение функции)
total += f2(x);
}

// Умножаем сумму высот на ширину для получения общей площади
return total * step;
}

// Метод трапеций
double T_trapezoid(double start, double end, int parts) 
	{
	// Вычисляем ширину одной трапеции
	double step = (end - start) / parts;
	// Начальная сумма - полусумма значений на краях интервала
	double total = (f2(start) + f2(end)) / 2;

	// Суммируем значения функции во всех внутренних точках
	for (int i = 1; i < parts; i++) {
	// Вычисляем x-координату текущей точки
	double x = start + i * step;
	// Добавляем значение функции в текущей точке
	total += f2(x);
	}

	// Умножаем сумму на шаг для получения общей площади
	return total * step;
	}


	int main() 
	{
	// подключение русского языка

	// ЧАСТЬ КОДА ДЛЯ ПЕРВОГО И ТЕРЕТЬЕГО ЗАДАНИЯ

	// Границы интегрирования
	double start = 0.4;    // Нижний предел
	double end = 2.2;      // Верхний предел
	double precision = 1e-6; // Требуемая точность

	cout<< "ВЫЧИСЛЕНИЕ ИНТЕГРАЛОВ ДЛЯ ПЕРВОГО И ТРЕТЬЕГО ЗАДАНИЯ"<< endl;

	// Выводим информацию о задаче
	cout << "Вычисляем интеграл от " << start << " до " << end << "\n\n";

	// ВЫЧИСЛЕНИЕ МЕТОДОМ ТРАПЕЦИЙ
	cout << "МЕТОД ТРАПЕЦИЙ:\n";
	int parts_trap = 8;          // Начальное число разбиений
	double old_trap, new_trap;   // Старое и новое значение интеграла
	int count_trap = 0;          // Счетчик итераций

	// Первое вычисление с начальным числом разбиений
	old_trap = trapezoid(start, end, parts_trap); // старт, конец, разбиение

	// Цикл уточнения результата, чтобы подобраться к разнице в (1e - 6) между old_trap и new_trap
	for (int i = 1; i <= 30; i++) // i <= 30, потому что не имеет смысла. точность не улучшится, а программа будет работать дольше 
	{
	parts_trap *= 2;                    // Удваиваем число разбиений
	new_trap = trapezoid(start, end, parts_trap); // Новое вычисление
	count_trap = i;                     // Запоминаем номер итерации

	// Проверяем достигнута ли требуемая точность - 1e - 6
	if (fabs(new_trap - old_trap) < precision) break;

	// Сохраняем текущее значение для следующей итерации
	old_trap = new_trap;
	}

	// Выводим результаты метода трапеций
	cout << "Значение интеграла: " << new_trap << endl;
	cout << "Потребовалось итераций: " << count_trap << endl;
	cout << "Финальное число разбиений: " << parts_trap << endl << endl;

	// ВЫЧИСЛЕНИЕ МЕТОДОМ СИМПСОНА
	cout << "МЕТОД СИМПСОНА:\n";
	int parts_simp = 8;          // Начальное число разбиений
	double old_simp, new_simp;   // Старое и новое значение интеграла
	int count_simp = 0;          // Счетчик итераций

	// Первое вычисление с начальным числом разбиений
	old_simp = simpson(start, end, parts_simp);

	// Цикл уточнения результата
	for (int i = 1; i <= 30; i++) 
	{
	parts_simp *= 2;                    // Удваиваем число разбиений
	new_simp = simpson(start, end, parts_simp); // Новое вычисление
	count_simp = i;                     // Запоминаем номер итерации

	// Проверяем достигнута ли требуемая точность
	if (fabs(new_simp - old_simp) < precision) break;

	// Сохраняем текущее значение для следующей итерации
	old_simp = new_simp;
	}

	// Выводим результаты метода Симпсона
	cout << "Значение интеграла: " << new_simp << endl;
	cout << "Потребовалось итераций: " << count_simp << endl;
	cout << "Финальное число разбиений: " << parts_simp << endl << endl;

	// ВЫЧИСЛЕНИЕ МЕТОДОМ ПРЯМОУГОЛЬНИКОВ
	cout << "МЕТОД ПРЯМОУГОЛЬНИКОВ:\n";
	int parts_rect = 8;          // Начальное число разбиений
	double old_rect, new_rect;   // Старое и новое значение интеграла
	int count_rect = 0;          // Счетчик итераций

	// Первое вычисление с начальным числом разбиений
	old_rect = rectangles(start, end, parts_rect);

	// Цикл уточнения результата
	for (int i = 1; i <= 30; i++) 
	{
	parts_rect *= 2;                    // Удваиваем число разбиений
	new_rect = rectangles(start, end, parts_rect); // Новое вычисление
	count_rect = i;                     // Запоминаем номер итерации

	// Проверяем достигнута ли требуемая точность
	if (fabs(new_rect - old_rect) < precision) break;

	// Сохраняем текущее значение для следующей итерации
	old_rect = new_rect;
	}

	// Выводим результаты метода прямоугольников
	cout << "Значение интеграла: " << new_rect << endl;
	cout << "Потребовалось итераций: " << count_rect << endl;
	cout << "Финальное число разбиений: " << parts_rect << endl << endl;



	// ЧАСТЬ КОДА ДЛЯ ВТОРОГО ЗАДАНИЯ

	cout<< "ВЫЧИСЛЕНИЕ ИНТЕГРАЛОВ ДЛЯ ВТОРОГО ЗАДАНИЯ"<< endl;
	// Границы интегрирования
	double T_start = 0.0;    // Нижний предел
	double T_end = 1.0;      // Верхний предел
	double T_precision = 1e-6; // Требуемая точность

	// Выводим информацию о задаче
	cout << "Вычисляем интеграл от " << T_start << " до " << T_end << "\n\n";

	// ВЫЧИСЛЕНИЕ МЕТОДОМ ПРЯМОУГОЛЬНИКОВ
	cout << "МЕТОД ПРЯМОУГОЛЬНИКОВ:\n";
	int T_parts_rect = 8;          // Начальное число разбиений
	double T_old_rect, T_new_rect;   // Старое и новое значение интеграла
	int T_count_rect = 0;          // Счетчик итераций

	// Первое вычисление с начальным числом разбиений
	T_old_rect = T_rectangles(T_start, T_end, T_parts_rect);

	// Цикл уточнения результата
	for (int i = 1; i <= 30; i++) {
	T_parts_rect *= 2;                    // Удваиваем число разбиений
	T_new_rect = T_rectangles(T_start, T_end, T_parts_rect); // Новое вычисление
	T_count_rect = i;                     // Запоминаем номер итерации

	// Проверяем достигнута ли требуемая точность
	if (fabs(T_new_rect - T_old_rect) < T_precision) break;

	// Сохраняем текущее значение для следующей итерации
	T_old_rect = T_new_rect;
	}

	// Выводим результаты метода прямоугольников
	cout << "Значение интеграла: " << T_new_rect << endl;
	cout << "Потребовалось итераций: " << T_count_rect << endl;
	cout << "Финальное число разбиений: " << T_parts_rect << endl << endl;

	// ВЫЧИСЛЕНИЕ МЕТОДОМ ТРАПЕЦИЙ
	cout << "МЕТОД ТРАПЕЦИЙ:\n";
	int T_parts_trap = 8;          // Начальное число разбиений
	double T_old_trap, T_new_trap;   // Старое и новое значение интеграла
	int T_count_trap = 0;          // Счетчик итераций

	// Первое вычисление с начальным числом разбиений
	T_old_trap = T_trapezoid(T_start, T_end, T_parts_trap);

	// Цикл уточнения результата
	for (int i = 1; i <= 30; i++) 
	{
	T_parts_trap *= 2;                    // Удваиваем число разбиений
	T_new_trap = T_trapezoid(T_start, T_end, T_parts_trap); // Новое вычисление
	T_count_trap = i;                     // Запоминаем номер итерации

	// Проверяем достигнута ли требуемая точность
	if (fabs(T_new_trap - T_old_trap) < T_precision) break;

	// Сохраняем текущее значение для следующей итерации
	T_old_trap = T_new_trap;
	}

	// Выводим результаты метода трапеций
	cout << "Значение интеграла: " << T_new_trap << endl;
	cout << "Потребовалось итераций: " << T_count_trap << endl;
	cout << "Финальное число разбиений: " << T_parts_trap << endl << endl;


	cout<< "---------------КОНЕЧНЫЕ ОТВЕТЫ НА ЗАДАНИЯ---------------"<< endl;
	cout<< endl;
	// ПЕРЕХОД К КОНЕЧНЫМ РЕЗУЛЬТАТАМ 

	cout<< "ПЕРВОЕ ЗАДАНИЕ: Методами трапеции и Симпсона вычислить интеграл"<< endl;

	// СРАВНЕНИЕ МЕТОДОВ
	cout << "СРАВНЕНИЕ МЕТОДОВ:\n";
	cout << "Метод трапеций: " << count_trap << " итераций\n";
	cout << "Метод Симпсона: " << count_simp << " итераций\n";

	// Определяем какой метод быстрее достиг точности
	if (count_simp < count_trap) 
	{
	cout << "Метод Симпсона сходится быстрее!\n";
	} 
	else if (count_trap < count_simp) 
	{
	cout << "Метод трапеций сходится быстрее!\n";
	} 
	else 
	{
	cout << "Оба метода сошлись за одинаковое число итераций!\n";
	}

	cout<< endl;
	cout<< "ВТОРОЕ ЗАДАНИЕ: Вычислить с заданной точностью по формуле трапеций и прямоугольников"<< endl;

	// СРАВНЕНИЕ МЕТОДОВ
	cout << "СРАВНЕНИЕ МЕТОДОВ:\n";
	cout << "Метод прямоугольников: " << T_count_rect << " итераций\n";
	cout << "Метод трапеций: " << T_count_trap << " итераций\n";

	// Определяем какой метод быстрее достиг точности
	if (T_count_trap < T_count_rect) 
	{
	cout << "Метод трапеций сходится быстрее!\n";
	} 
	else if (T_count_rect < T_count_trap) 
	{
	cout << "Метод прямоугольников сходится быстрее!\n";
	} 
	else 
	{
	cout << "Оба метода сошлись за одинаковое число итераций!\n";
	}
	cout<< endl;
	cout<< "ТРЕТЬЕ ЗАДАНИЕ: Методом Симпсона и прямоугольников вычислить с заданной точностью интеграл"<< endl;

	// СРАВНЕНИЕ МЕТОДОВ
	cout << "СРАВНЕНИЕ МЕТОДОВ:\n";
	cout << "Метод прямоугольников: " << count_rect << " итераций\n";
	cout << "Метод Симпсона: " << count_simp << " итераций\n";

	// Определяем какой метод быстрее достиг точности
	if (count_simp < count_rect) 
	{
	cout << "Метод Симпсона сходится быстрее!\n";
	} 
	else if (count_rect < count_simp) 
	{
	cout << "Метод прямоугольников сходится быстрее!\n";
	} 
	else 
	{
	cout << "Оба метода сошлись за одинаковое число итераций!\n";
	}

	return 0;
	}
