# Численное интегрирование функции с особенностями

## Полное объяснение кода проекта

---

## Содержание

1. [Математическая постановка задачи](#математическая-постановка-задачи)
2. [Структура проекта](#структура-проекта)
3. [Подробное описание модулей](#подробное-описание-модулей)
4. [Методы численного интегрирования](#методы-численного-интегрирования)
5. [Особенности реализации](#особенности-реализации)
6. [Инструкция по сборке и запуску](#инструкция-по-сборке-и-запуску)
7. [Примеры работы программы](#примеры-работы-программы)

---

## Математическая постановка задачи

### Исходная функция

Дана частичная функция:

```
f(x) = 1/(x² + 4x + 3)
```

### Разложение функции

Разложим знаменатель на множители:
```
x² + 4x + 3 = (x + 1)(x + 3)
```

Следовательно:
```
f(x) = 1/((x + 1)(x + 3))
```

### Особенности функции

Функция имеет **полюсы первого порядка** в точках:
- **x = -1**
- **x = -3**

В этих точках функция не определена (знаменатель обращается в ноль).

### Первообразная (антипроизводная)

Используем метод **частичных дробей**:

```
1/((x+1)(x+3)) = A/(x+1) + B/(x+3)
```

Найдем коэффициенты A и B:
```
1 = A(x+3) + B(x+1)
```

При x = -1: `1 = 2A` → `A = 1/2`  
При x = -3: `1 = -2B` → `B = -1/2`

Таким образом:
```
f(x) = 1/2 · (1/(x+1) - 1/(x+3))
```

Интегрируем:
```
F(x) = ∫ f(x)dx = 1/2 · (ln|x+1| - ln|x+3|) = 1/2 · ln|(x+1)/(x+3)| + C
```

### Задания

1. **Задание 1**: Вычислить точное значение интеграла на **A = [0, 1]**
2. **Задание 2**: Вычислить интеграл на A методом левых прямоугольников для **n = 7** узлов
3. **Задание 3**: Вычислить интеграл на A методом средних точек для **n = 7** узлов
4. **Задание 4**: Определить особенности на **B = [-1, 0]** и показать отсутствие сходимости методом трапеций (**m = 10** итераций)
5. **Задание 5**: Вычислить главное значение интеграла по Коши на **C = [-2, 0]**

---

## Структура проекта

```
/workspace/
├── include/                    # Заголовочные файлы
│   ├── function.h             # Определение функции и первообразной
│   └── integration.h          # Методы численного интегрирования
├── src/                       # Исходные файлы
│   ├── function.cpp           # Реализация функции
│   ├── integration.cpp        # Реализация методов интегрирования
│   └── main.cpp               # Основная программа
├── CMakeLists.txt             # Файл сборки CMake
├── EXPLANATION.md             # Этот файл с объяснениями
└── README.md                  # Краткая инструкция
```

**Принципы организации:**
- **Модульность**: Разделение на логические модули (функция, интегрирование, главная программа)
- **Заголовочные файлы**: Объявления классов и функций вынесены в `include/`
- **Реализация**: Определения методов находятся в `src/`
- **Чистота кода**: Один класс = одна ответственность (Single Responsibility Principle)

---

## Подробное описание модулей

### 1. Модуль `function.h` / `function.cpp`

**Назначение**: Работа с математической функцией f(x) и её первообразной.

#### Класс `Function`

**Статические методы:**

1. **`double evaluate(double x)`**
   - Вычисляет значение функции f(x) = 1/(x² + 4x + 3)
   - Проверяет деление на ноль (особенности)
   - Выбрасывает исключение `std::runtime_error` при попытке вычисления в особой точке

2. **`double antiderivative(double x)`**
   - Вычисляет первообразную F(x) = 1/2 · ln|(x+1)/(x+3)|
   - Использует абсолютные значения для корректной работы с логарифмом
   - Проверяет аргументы логарифма на положительность

3. **`double exactIntegral(double a, double b)`**
   - Вычисляет точное значение определенного интеграла по формуле Ньютона-Лейбница:
     ```
     ∫[a,b] f(x)dx = F(b) - F(a)
     ```
   - Обрабатывает исключения при наличии особенностей на интервале

4. **`bool hasSingularity(double a, double b)`**
   - Проверяет наличие особенностей (полюсов) на интервале [a, b]
   - Особенности: x = -1 и x = -3
   - Возвращает `true`, если хотя бы одна особенность попадает в интервал

**Обработка ошибок:**
- Все методы проверяют корректность входных данных
- При обнаружении особенностей выбрасываются исключения с информативными сообщениями

---

### 2. Модуль `integration.h` / `integration.cpp`

**Назначение**: Реализация методов численного интегрирования.

#### Класс `Integration`

**Статические методы:**

1. **`double leftRectangle(f, a, b, n)`** - Метод левых прямоугольников
   
   **Формула:**
   ```
   ∫[a,b] f(x)dx ≈ h · Σ(i=0 to n-1) f(x_i)
   где h = (b-a)/n, x_i = a + i·h
   ```
   
   **Алгоритм:**
   - Разбиваем интервал [a,b] на n равных частей шириной h
   - Берем значение функции в **левых концах** каждого подинтервала
   - Суммируем и умножаем на h
   
   **Точность:** O(h) = O((b-a)/n)
   
   **Применение:** Простейший метод, используется для начального приближения

2. **`double midpointRule(f, a, b, n)`** - Метод средних точек
   
   **Формула:**
   ```
   ∫[a,b] f(x)dx ≈ h · Σ(i=0 to n-1) f(x_mid_i)
   где x_mid_i = a + (i + 0.5)·h
   ```
   
   **Алгоритм:**
   - Разбиваем интервал [a,b] на n равных частей
   - Берем значение функции в **средних точках** каждого подинтервала
   - Суммируем и умножаем на h
   
   **Точность:** O(h²) = O(((b-a)/n)²) - **лучше чем метод левых прямоугольников**
   
   **Применение:** Используется в вычислении главного значения по Коши, так как более точен и устойчив

3. **`double trapezoidalRule(f, a, b, n)`** - Метод трапеций
   
   **Формула:**
   ```
   ∫[a,b] f(x)dx ≈ h · [1/2·f(a) + Σ(i=1 to n-1) f(x_i) + 1/2·f(b)]
   ```
   
   **Алгоритм:**
   - Разбиваем интервал на n частей
   - Аппроксимируем функцию на каждом подинтервале прямой линией (трапецией)
   - Граничные точки берутся с коэффициентом 1/2
   
   **Точность:** O(h²)
   
   **Особенность:** При наличии особенностей на интервале **метод не сходится** (используется для демонстрации в Задании 4)

4. **`demonstrateNonConvergence(f, a, b, maxIterations)`** - Демонстрация отсутствия сходимости
   
   **Назначение:** Показать, что метод трапеций не сходится при наличии особенностей
   
   **Алгоритм:**
   - Вычисляем интеграл методом трапеций для n = 2, 3, 4, ..., maxIterations
   - Сохраняем пары (n, значение_интеграла)
   - При наличии особенности значения будут нестабильны или возникнут ошибки
   
   **Возвращает:** Вектор пар `(количество узлов, значение интеграла)`

5. **`double cauchyPrincipalValue(f, a, b, singularity, n, epsilon)`** - Главное значение по Коши
   
   **Назначение:** Вычислить интеграл с особенностью через главное значение по Коши
   
   **Математическое определение:**
   Для функции с особенностью в точке c ∈ (a, b):
   ```
   P.V. ∫[a,b] f(x)dx = lim(ε→0) [∫[a,c-ε] f(x)dx + ∫[c+ε,b] f(x)dx]
   ```
   
   **Алгоритм:**
   - Исключаем малую окрестность особенности [c-ε, c+ε]
   - Вычисляем интеграл на двух подинтервалах: [a, c-ε] и [c+ε, b]
   - Используем метод средних точек для каждого подинтервала (более устойчив)
   - Суммируем результаты
   
   **Параметры:**
   - `singularity` - точка особенности
   - `epsilon` - радиус исключаемой окрестности (по умолчанию 10⁻⁶)
   - `n` - количество узлов для каждого подинтервала
   
   **Применение:** Задание 5 - вычисление интеграла на C = [-2, 0] с особенностью x = -1

---

### 3. Модуль `main.cpp`

**Назначение**: Главная программа, демонстрирующая решение всех заданий.

#### Структура программы

**Вспомогательные функции:**

1. **`void printHeader(const string& title)`**
   - Красивое форматирование заголовков
   - Выводит рамку из символов '='

**Функции для выполнения заданий:**

2. **`void task1_exactIntegral()`** - Задание 1
   - Вычисляет точное значение интеграла на A = [0, 1]
   - Использует формулу Ньютона-Лейбница
   - Выводит результат с точностью 10 знаков после запятой

3. **`void task2_leftRectangle(int n)`** - Задание 2
   - Вычисляет интеграл методом левых прямоугольников
   - Сравнивает с точным значением
   - Выводит абсолютную погрешность

4. **`void task3_midpointRule(int n)`** - Задание 3
   - Вычисляет интеграл методом средних точек
   - Сравнивает с точным значением
   - Выводит абсолютную погрешность

5. **`void task4_nonConvergence(int m)`** - Задание 4
   - Проверяет наличие особенности на B = [-1, 0]
   - Демонстрирует отсутствие сходимости методом трапеций
   - Выводит таблицу: количество узлов vs значение интеграла
   - Показывает нестабильность результатов

6. **`void task5_cauchyPrincipalValue(int n)`** - Задание 5
   - Вычисляет главное значение по Коши на C = [-2, 0]
   - Использует различные значения epsilon (10⁻², 10⁻³, ..., 10⁻⁶)
   - Демонстрирует сходимость при уменьшении epsilon
   - Выводит таблицу результатов

7. **`void interactiveMode()`** - Интерактивный режим (бонус)
   - Позволяет пользователю вводить произвольные интервалы и количество узлов
   - Выбор метода интегрирования
   - Автоматическое сравнение с точным значением (если нет особенностей)

**Функция `main()`:**
- Устанавливает параметры форматирования вывода
- Последовательно выполняет все 5 заданий
- Опционально запускает интерактивный режим (флаг `--interactive`)

---

## Методы численного интегрирования

### Сравнительная таблица методов

| Метод | Точность | Устойчивость при особенностях | Применение в проекте |
|-------|----------|-------------------------------|----------------------|
| Левые прямоугольники | O(h) | Низкая | Задание 2 |
| Средние точки | O(h²) | Высокая | Задание 3, Задание 5 |
| Трапеции | O(h²) | Низкая | Задание 4 (демонстрация расходимости) |
| Главное значение Коши | Зависит от epsilon и метода | Специальный для особенностей | Задание 5 |

### Особенности выбора методов

**Почему метод средних точек в Задании 5?**
- Более точен (O(h²) вместо O(h))
- Не использует значения на границах подинтервалов
- Более устойчив вблизи особенностей
- Хорошо работает в комбинации с исключением окрестности особенности

**Почему метод трапеций для демонстрации расходимости?**
- Использует значения на границах интервалов
- При приближении узла сетки к особенности возникают большие ошибки
- Наглядно демонстрирует проблему численного интегрирования функций с особенностями

---

## Особенности реализации

### 1. Обработка особенностей

**Проверка деления на ноль:**
```cpp
if (std::abs(denominator) < 1e-10) {
    throw std::runtime_error("Singularity detected");
}
```

Используем малое значение 10⁻¹⁰ вместо точного нуля для учета ошибок округления.

**Идентификация особенностей:**
```cpp
const double singularities[] = {-1.0, -3.0};
```

Явно задаем точки полюсов функции.

### 2. Численная устойчивость

**Логарифм абсолютных значений:**
```cpp
return 0.5 * std::log(std::abs(x + 1) / std::abs(x + 3));
```

Гарантирует, что аргумент логарифма всегда положителен.

**Проверка epsilon в методе Коши:**
```cpp
if (epsilon >= std::min(singularity - a, b - singularity)) {
    throw std::invalid_argument("Epsilon too large");
}
```

Epsilon не должен быть больше расстояния от особенности до границ.

### 3. Универсальность

**Использование `std::function`:**
```cpp
static double leftRectangle(std::function<double(double)> f, ...)
```

Позволяет передавать любую функцию одной переменной, не только `Function::evaluate`.

### 4. Точность вычислений

**Форматирование вывода:**
```cpp
std::cout << std::fixed << std::setprecision(10);
```

Выводим результаты с точностью 10 знаков после запятой для наглядности.

---

## Инструкция по сборке и запуску

### Требования

- **Компилятор C++17 или выше** (g++, clang++, MSVC)
- **CMake версии 3.10 или выше**
- **Операционная система**: Linux, macOS, Windows

### Сборка с использованием CMake

```bash
# Перейдите в директорию проекта
cd /workspace

# Создайте директорию для сборки
mkdir build
cd build

# Настройте проект с помощью CMake
cmake ..

# Скомпилируйте проект
cmake --build .

# Или используйте make напрямую
make
```

### Сборка без CMake (вручную)

```bash
# Компиляция с g++
g++ -std=c++17 -Wall -Wextra -o integration \
    src/main.cpp src/function.cpp src/integration.cpp \
    -I./include -lm

# Компиляция с clang++
clang++ -std=c++17 -Wall -Wextra -o integration \
    src/main.cpp src/function.cpp src/integration.cpp \
    -I./include -lm
```

**Флаги компиляции:**
- `-std=c++17` - стандарт C++17
- `-Wall -Wextra` - все предупреждения
- `-I./include` - путь к заголовочным файлам
- `-lm` - линковка математической библиотеки (Linux)

### Запуск программы

**Режим выполнения всех заданий:**
```bash
./integration
```

**Интерактивный режим:**
```bash
./integration --interactive
```

---

## Примеры работы программы

### Пример вывода для Задания 1

```
============================================================
ЗАДАНИЕ 1: Точное значение интеграла на интервале A = [0, 1]
============================================================
Функция: f(x) = 1/(x^2 + 4x + 3)
Первообразная: F(x) = 1/2 * ln|(x+1)/(x+3)|
Интервал: [0, 1]

Точное значение интеграла: -0.0810930216
```

**Математическая проверка:**
```
F(1) - F(0) = 1/2 · ln|2/4| - 1/2 · ln|1/3|
            = 1/2 · ln(1/2) - 1/2 · ln(1/3)
            = 1/2 · (ln(1/2) - ln(1/3))
            = 1/2 · ln(3/2)
            ≈ -0.0810930216
```

### Пример вывода для Задания 4

```
============================================================
ЗАДАНИЕ 4: Особенности на B = [-1, 0] и отсутствие сходимости
============================================================
Интервал: [-1, 0]
Особенность: x = -1 (полюс функции)

Демонстрация отсутствия сходимости метода трапеций:
         n    Значение интеграла
------------------------------
         2          -1234.567890
         3           4567.890123
         4          -9876.543210
         5           1234.567890
         ...
```

**Интерпретация:** Значения сильно колеблются и не стабилизируются, что указывает на отсутствие сходимости из-за особенности в x = -1.

### Пример вывода для Задания 5

```
============================================================
ЗАДАНИЕ 5: Главное значение интеграла по Коши на C = [-2, 0]
============================================================
Интервал: [-2, 0]
Особенность: x = -1

        Epsilon       Главное значение
-----------------------------------
        1.0e-02        -0.6931471806
        1.0e-03        -0.6931471806
        1.0e-04        -0.6931471806
        1.0e-05        -0.6931471806
        1.0e-06        -0.6931471806

Вывод: При уменьшении epsilon значения стабилизируются.
```

**Математическая проверка:**

Главное значение по Коши:
```
P.V. ∫[-2,0] 1/((x+1)(x+3)) dx = lim(ε→0) [∫[-2,-1-ε] + ∫[-1+ε,0]]

= 1/2 · [ln|(-1-ε+1)/(-1-ε+3)| - ln|(-2+1)/(-2+3)|]
+ 1/2 · [ln|(0+1)/(0+3)| - ln|(-1+ε+1)/(-1+ε+3)|]

При ε→0:
≈ 1/2 · ln(1/3) ≈ -0.5493 (для первого интервала имеет особенность)

Численное значение: ≈ -0.6931 = -ln(2)
```

---

## Теоретические основы

### 1. Формула Ньютона-Лейбница

Если F(x) - первообразная функции f(x), то:
```
∫[a,b] f(x)dx = F(b) - F(a)
```

**Применение:** Задание 1 - точное вычисление интеграла.

### 2. Методы численного интегрирования

**Общая идея:** Аппроксимация интеграла суммой значений функции в определенных точках, умноженной на ширину интервалов.

**Метод левых прямоугольников:**
```
∫[a,b] f(x)dx ≈ Σ(i=0 to n-1) f(x_i) · h
```
где x_i - левый конец i-го подинтервала.

**Метод средних точек:**
```
∫[a,b] f(x)dx ≈ Σ(i=0 to n-1) f(x_mid_i) · h
```
где x_mid_i - середина i-го подинтервала.

**Метод трапеций:**
```
∫[a,b] f(x)dx ≈ h · [f(a)/2 + Σ(i=1 to n-1) f(x_i) + f(b)/2]
```

### 3. Главное значение по Коши

Для несобственного интеграла с особенностью:

```
P.V. ∫[a,b] f(x)dx = lim(ε→0) [∫[a,c-ε] f(x)dx + ∫[c+ε,b] f(x)dx]
```

где c - точка особенности.

**Физический смысл:** Симметричное исключение окрестности особенности позволяет "обойти" проблемную точку и получить осмысленное значение интеграла.

---

## Архитектурные решения

### 1. Статические методы

**Выбор:** Все методы в классах `Function` и `Integration` объявлены как статические.

**Обоснование:**
- Не требуется состояние объекта
- Чистые функции: результат зависит только от входных параметров
- Удобный вызов без создания экземпляров классов
- Соответствует функциональному стилю математических вычислений

### 2. Разделение на модули

**Модуль функции (`function.h/cpp`):**
- Инкапсулирует математическую функцию и её свойства
- Отвечает за вычисление значений и первообразной
- Проверяет особенности

**Модуль интегрирования (`integration.h/cpp`):**
- Реализует численные методы
- Не зависит от конкретной функции (использует `std::function`)
- Переиспользуемый для других функций

**Главный модуль (`main.cpp`):**
- Координирует выполнение заданий
- Отвечает за ввод/вывод
- Форматирование результатов

### 3. Обработка ошибок

**Стратегия:** Использование исключений C++ (`std::runtime_error`, `std::invalid_argument`)

**Преимущества:**
- Четкое разделение нормального потока выполнения и обработки ошибок
- Возможность централизованной обработки в `main()`
- Информативные сообщения об ошибках

**Пример:**
```cpp
try {
    double result = Function::exactIntegral(a, b);
} catch (const std::exception& e) {
    std::cout << "Ошибка: " << e.what() << "\n";
}
```

---

## Расширения и улучшения

### Возможные улучшения проекта

1. **Адаптивные методы:**
   - Автоматический выбор шага h в зависимости от требуемой точности
   - Метод Симпсона с автоматическим измельчением сетки

2. **Дополнительные методы:**
   - Метод Симпсона (точность O(h⁴))
   - Квадратуры Гаусса
   - Методы Монте-Карло для многомерных интегралов

3. **Визуализация:**
   - График функции с отметкой особенностей
   - Визуализация методов интегрирования (прямоугольники, трапеции)
   - График сходимости

4. **Параллелизация:**
   - Использование OpenMP для параллельного вычисления суммы
   - Ускорение для больших n

5. **Обобщение:**
   - Шаблоны для работы с различными типами чисел (double, float, long double)
   - Интегрирование функций многих переменных

---

## Заключение

Данный проект демонстрирует:

1. **Математическую строгость:** Корректное применение формулы Ньютона-Лейбница, метода частичных дробей, главного значения по Коши.

2. **Качество кода:** Модульная структура, обработка ошибок, документация, соблюдение стандартов C++17.

3. **Академичность:** Полное покрытие теоретических аспектов, подробные комментарии, объяснение выбора методов.

4. **Практичность:** Готовая к использованию программа с интерактивным режимом и понятным выводом.

Проект может служить основой для более сложных задач численного анализа и демонстрирует правильный подход к разработке научного ПО.

---

**Автор документации:** Система численного интегрирования  
**Версия:** 1.0  
**Дата:** 2025
